// Plabayo News
// Copyright (C) 2021  Glen Henri J. De Cauwsemaecker
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.

//! this pages module is auto-generated by the plabayo-news-builder::i18n crate.
//! DO NOT MODIFY MANUALLY AS IT WILL BE OVERWRITTEN NEXT TIME YOU BUILD USING CARGO!!!
//! ... Best to also not check in this file into remote repo.

use actix_web::error::ErrorInternalServerError;
use actix_web::{http::StatusCode, HttpResponse, Result};
use askama::Template;

use crate::site::templates::PageState;
use crate::site::{assets, SiteInfo, SITE_INFO};

use super::models::{ContentIndex, ContentItem, ContentSearch};

//-------------------------------------
//------- STATIC PAGES
//-------------------------------------

pub fn is_static_root(root: &str) -> bool {
    matches!(
        root.to_lowercase().as_str(),
        assets::ROOT
            | PAGE_API_ENDPOINT
            | PAGE_CONTRIBUTE_ENDPOINT
            | PAGE_FAQ_ENDPOINT
            | PAGE_GUIDELINES_ENDPOINT
            | PAGE_SECURITY_ENDPOINT
    )
}

pub fn static_response<'a>(site_info: &'a SiteInfo, page: PageState<'a>) -> HttpResponse {
    let s = (match endpoint {
        PAGE_API_ENDPOINT => PageApi::new(site_info, page),
        PAGE_CONTRIBUTE_ENDPOINT => PageContribute::new(site_info, page),
        PAGE_FAQ_ENDPOINT => PageFaq::new(site_info, page),
        PAGE_GUIDELINES_ENDPOINT => PageGuidelines::new(site_info, page),
        PAGE_SECURITY_ENDPOINT => PageSecurity::new(site_info, page),
        _ => PageUnknown::new(site_info, page),
    })
    .render()
    .map_err(ErrorInternalServerError)?;
    Ok(HttpResponse::Ok().content_type("text/html").body(s))
}

const PAGE_API_ENDPOINT: &str = "api";

#[template(path = "pages/api.html")]
struct PageApi<'a> {
    site_info: &'a SiteInfo,
    page: PageState<'a>,
}

impl<'a> PageApi<'a> {
    pub fn new(page: PageState<'a>) -> Api<'a> {
        Api {
            site_info: &SITE_INFO,
            page,
        }
    }
}

const PAGE_CONTRIBUTE_ENDPOINT: &str = "contribute";

#[template(path = "pages/contribute.html")]
struct PageContribute<'a> {
    site_info: &'a SiteInfo,
    page: PageState<'a>,
}

impl<'a> PageContribute<'a> {
    pub fn new(page: PageState<'a>) -> Contribute<'a> {
        Contribute {
            site_info: &SITE_INFO,
            page,
        }
    }
}

const PAGE_FAQ_ENDPOINT: &str = "faq";

#[template(path = "pages/faq.html")]
struct PageFaq<'a> {
    site_info: &'a SiteInfo,
    page: PageState<'a>,
}

impl<'a> PageFaq<'a> {
    pub fn new(page: PageState<'a>) -> Faq<'a> {
        Faq {
            site_info: &SITE_INFO,
            page,
        }
    }
}

const PAGE_GUIDELINES_ENDPOINT: &str = "guidelines";

#[template(path = "pages/guidelines.html")]
struct PageGuidelines<'a> {
    site_info: &'a SiteInfo,
    page: PageState<'a>,
}

impl<'a> PageGuidelines<'a> {
    pub fn new(page: PageState<'a>) -> Guidelines<'a> {
        Guidelines {
            site_info: &SITE_INFO,
            page,
        }
    }
}

const PAGE_SECURITY_ENDPOINT: &str = "security";

#[template(path = "pages/security.html")]
struct PageSecurity<'a> {
    site_info: &'a SiteInfo,
    page: PageState<'a>,
}

impl<'a> PageSecurity<'a> {
    pub fn new(page: PageState<'a>) -> Security<'a> {
        Security {
            site_info: &SITE_INFO,
            page,
        }
    }
}

const PAGE_UNKNOWN_ENDPOINT: &str = "unknown";

#[template(path = "pages/unknown.html")]
struct PageUnknown<'a> {
    site_info: &'a SiteInfo,
    page: PageState<'a>,
}

impl<'a> PageUnknown<'a> {
    pub fn new(page: PageState<'a>) -> Unknown<'a> {
        Unknown {
            site_info: &SITE_INFO,
            page,
        }
    }
}

//-------------------------------------
//------- DYNAMIC PAGES
//-------------------------------------

#[derive(Template)]
#[template(path = "pages/index.html")]
pub struct PageIndex<'a> {
    site_info: &'a SiteInfo,
    page: PageState<'a>,
    content: ContentIndex,
}

impl<'a> PageIndex<'a> {
    pub fn new_response(page: PageState<'a>, content: ContentIndex) -> Result<HttpResponse> {
        let page = Index {
            site_info: &SITE_INFO,
            page,
            content,
        };
        let s = page.render().map_err(ErrorInternalServerError)?;
        Ok(HttpResponse::Ok().content_type("text/html").body(s))
    }
}
#[derive(Template)]
#[template(path = "pages/item.html")]
pub struct PageItem<'a> {
    site_info: &'a SiteInfo,
    page: PageState<'a>,
    content: ContentItem,
}

impl<'a> PageItem<'a> {
    pub fn new_response(page: PageState<'a>, content: ContentItem) -> Result<HttpResponse> {
        let page = Item {
            site_info: &SITE_INFO,
            page,
            content,
        };
        let s = page.render().map_err(ErrorInternalServerError)?;
        Ok(HttpResponse::Ok().content_type("text/html").body(s))
    }
}
#[derive(Template)]
#[template(path = "pages/search.html")]
pub struct PageSearch<'a> {
    site_info: &'a SiteInfo,
    page: PageState<'a>,
    content: ContentSearch,
}

impl<'a> PageSearch<'a> {
    pub fn new_response(page: PageState<'a>, content: ContentSearch) -> Result<HttpResponse> {
        let page = Search {
            site_info: &SITE_INFO,
            page,
            content,
        };
        let s = page.render().map_err(ErrorInternalServerError)?;
        Ok(HttpResponse::Ok().content_type("text/html").body(s))
    }
}
